/**
 * Context Command Integration Tests - Subprocess-based behavioral tests
 *
 * These tests run the CLI as a subprocess to test the context command
 * end-to-end behavior with real artifacts.
 *
 * Domain invariants:
 * - Command requires artifact ID as argument
 * - Command generates context in three formats: standard, compact, detailed
 * - Standard format includes artifact + parent context
 * - Compact format includes only artifact essentials
 * - Detailed format includes full parent hierarchy and relationships
 * - Command copies to clipboard with --copy flag
 * - Command saves to file with --output flag
 * - Command errors gracefully when artifact not found
 * - Command validates format flag values
 */

import { readFile, unlink } from "node:fs/promises";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { execa } from "execa";
import stripAnsi from "strip-ansi";
import { afterEach, describe, expect, it } from "vitest";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const cliPath = join(__dirname, "../dist/index.js");
// Run from repository root where .kodebase/ directory exists
const repoRoot = join(__dirname, "../../..");

/**
 * Execute the CLI with given arguments
 */
const runCLI = async (args: string[]) => {
  const result = await execa("node", [cliPath, ...args], {
    reject: false,
    cwd: repoRoot,
    env: { FORCE_COLOR: "0" }, // Disable colors for easier assertions
  });

  return {
    stdout: stripAnsi(result.stdout),
    stderr: stripAnsi(result.stderr),
    exitCode: result.exitCode,
    output: stripAnsi(result.stdout + result.stderr),
  };
};

// Track temporary files for cleanup
const tempFiles: string[] = [];

afterEach(async () => {
  // Clean up temporary files
  for (const file of tempFiles) {
    try {
      await unlink(file);
    } catch {
      // Ignore errors - file might not exist
    }
  }
  tempFiles.length = 0;
});

describe("context command", () => {
  describe("basic context generation", () => {
    it("requires artifact ID as argument", async () => {
      const { output } = await runCLI(["ctx"]);

      expect(output).toContain("Artifact ID is required");
      expect(output).toContain("Usage: kb ctx");
    });

    it("generates standard context for valid artifact", async () => {
      const { output, exitCode } = await runCLI(["ctx", "E.3.2"]);

      // Standard format should include header
      expect(output).toContain("# Artifact E.3.2:");
      expect(output).toContain("Implement Context Command");

      // Should include parent context
      expect(output).toContain("## Parent Context");
      expect(output).toContain("Initiative E:");
      expect(output).toContain("Milestone E.3:");

      // Should include description
      expect(output).toContain("## Description");

      // Should include acceptance criteria
      expect(output).toContain("## Acceptance Criteria");

      // Should include metadata
      expect(output).toContain("## Metadata");
      expect(output).toContain("Priority:");
      expect(output).toContain("Estimation:");

      // Should include footer
      expect(output).toContain("Context generated by Kodebase CLI");

      expect(exitCode).toBe(0);
    });

    it("shows error for non-existent artifact", async () => {
      const { output } = await runCLI(["ctx", "Z.99.99"]);

      expect(output).toContain("Artifact Z.99.99 not found");
    });

    it("supports 'context' as full command name", async () => {
      const { output, exitCode } = await runCLI(["context", "E.3.2"]);

      expect(output).toContain("# Artifact E.3.2:");
      expect(exitCode).toBe(0);
    });
  });

  describe("format variations", () => {
    it("generates compact context with --format=compact", async () => {
      const { output, exitCode } = await runCLI([
        "ctx",
        "E.3.2",
        "--format=compact",
      ]);

      // Compact format should use short header
      expect(output).toContain("# E.3.2:");

      // Should include criteria
      expect(output).toContain("**Criteria:**");

      // Should NOT include parent context section
      expect(output).not.toContain("## Parent Context");

      // Should NOT include detailed metadata
      expect(output).not.toContain("## Metadata");

      expect(exitCode).toBe(0);
    });

    it("generates detailed context with --format=detailed", async () => {
      const { output, exitCode } = await runCLI([
        "ctx",
        "E.3.2",
        "--format=detailed",
      ]);

      // Detailed format should include full parent hierarchy
      expect(output).toContain("## Parent Hierarchy");
      expect(output).toContain("### Initiative E");
      expect(output).toContain("### Milestone E.3");

      // Should include current artifact section
      expect(output).toContain("## Current Artifact");

      // Should include relationships section
      expect(output).toContain("## Relationships");

      // Should include extended metadata
      expect(output).toContain("## Metadata");
      expect(output).toContain("Created By:");

      // Should include detailed footer
      expect(output).toContain("*Detailed context generated by Kodebase CLI*");

      expect(exitCode).toBe(0);
    });

    it("validates format flag values", async () => {
      const { output } = await runCLI(["ctx", "E.3.2", "--format=invalid"]);

      expect(output).toContain("Invalid format: invalid");
      expect(output).toContain("Must be one of: standard, compact, detailed");
    });

    it("defaults to standard format when no format specified", async () => {
      const { output: withoutFlag } = await runCLI(["ctx", "E.3.2"]);
      const { output: withStandard } = await runCLI([
        "ctx",
        "E.3.2",
        "--format=standard",
      ]);

      // Both should produce same output
      expect(withoutFlag).toBe(withStandard);
    });
  });

  describe("clipboard functionality", () => {
    it("shows success message with --copy flag", async () => {
      const { output, exitCode } = await runCLI(["ctx", "E.3.2", "--copy"]);

      // Should show context
      expect(output).toContain("# Artifact E.3.2:");

      // Should show success message
      expect(output).toContain("Context copied to clipboard");

      expect(exitCode).toBe(0);
    });

    it("combines --copy with format flags", async () => {
      const { output, exitCode } = await runCLI([
        "ctx",
        "E.3.2",
        "--format=compact",
        "--copy",
      ]);

      // Should show compact format
      expect(output).toContain("# E.3.2:");

      // Should show clipboard success
      expect(output).toContain("Context copied to clipboard");

      expect(exitCode).toBe(0);
    });
  });

  describe("file output functionality", () => {
    it("saves context to file with --output flag", async () => {
      const outputPath = join(repoRoot, "test-context-output.md");
      tempFiles.push(outputPath);

      const { output, exitCode } = await runCLI([
        "ctx",
        "E.3.2",
        `--output=${outputPath}`,
      ]);

      // Should show context
      expect(output).toContain("# Artifact E.3.2:");

      // Should show success message with full path
      expect(output).toContain("Context saved to");
      expect(output).toContain(outputPath);

      // File should exist and contain context
      const fileContent = await readFile(outputPath, "utf-8");
      expect(fileContent).toContain("# Artifact E.3.2:");
      expect(fileContent).toContain("Implement Context Command");
      expect(fileContent).toContain("## Parent Context");

      expect(exitCode).toBe(0);
    });

    it("supports relative paths for --output flag", async () => {
      const outputPath = join(repoRoot, "test-relative.md");
      tempFiles.push(outputPath);

      const { output, exitCode } = await runCLI([
        "ctx",
        "E.3.2",
        "--output=test-relative.md",
      ]);

      expect(output).toContain("Context saved to");
      expect(exitCode).toBe(0);

      // File should exist
      const fileContent = await readFile(outputPath, "utf-8");
      expect(fileContent).toContain("# Artifact E.3.2:");
    });

    it("combines --output with format flags", async () => {
      const outputPath = join(repoRoot, "test-compact-output.md");
      tempFiles.push(outputPath);

      const { exitCode } = await runCLI([
        "ctx",
        "E.3.2",
        "--format=compact",
        `--output=${outputPath}`,
      ]);

      expect(exitCode).toBe(0);

      // File should contain compact format
      const fileContent = await readFile(outputPath, "utf-8");
      expect(fileContent).toContain("# E.3.2:");
      expect(fileContent).not.toContain("## Parent Context");
    });

    it("combines --copy and --output flags", async () => {
      const outputPath = join(repoRoot, "test-copy-and-output.md");
      tempFiles.push(outputPath);

      const { output, exitCode } = await runCLI([
        "ctx",
        "E.3.2",
        "--copy",
        `--output=${outputPath}`,
      ]);

      // Should show both success messages
      expect(output).toContain("Context copied to clipboard");
      expect(output).toContain("Context saved to");

      expect(exitCode).toBe(0);

      // File should exist
      const fileContent = await readFile(outputPath, "utf-8");
      expect(fileContent).toContain("# Artifact E.3.2:");
    });
  });

  describe("context content validation", () => {
    it("includes relationships when present", async () => {
      const { output, exitCode } = await runCLI(["ctx", "E.3.2"]);

      // E.3.2 has relationships
      expect(output).toContain("## Relationships");
      expect(output).toContain("Dependencies (blocked by):");
      expect(output).toContain("E.3.1");
      expect(output).toContain("Blocks:");
      expect(output).toContain("E.3.3");

      expect(exitCode).toBe(0);
    });

    it("includes assignee when present in metadata", async () => {
      const { output, exitCode } = await runCLI(["ctx", "E.3.2"]);

      expect(output).toContain("Assignee:");
      expect(output).toContain("Miguel Carvalho");

      expect(exitCode).toBe(0);
    });

    it("includes parent context for nested artifacts", async () => {
      const { output, exitCode } = await runCLI(["ctx", "E.3.2"]);

      // Should show initiative (E) and milestone (E.3) in parent context
      expect(output).toContain("**Initiative E:**");
      expect(output).toContain("**Milestone E.3:**");

      expect(exitCode).toBe(0);
    });

    it("handles initiative-level artifacts (no parents)", async () => {
      const { output, exitCode } = await runCLI(["ctx", "E"]);

      // Should not have parent context section for initiative
      expect(output).toContain("# Artifact E:");
      expect(output).not.toContain("## Parent Context");

      expect(exitCode).toBe(0);
    });
  });

  describe("help integration", () => {
    it("context command appears in help output", async () => {
      const { stdout, exitCode } = await runCLI(["--help"]);

      expect(exitCode).toBe(0);
      expect(stdout).toContain("ctx");
      expect(stdout).toContain("Generate AI context");
    });
  });

  describe("error handling", () => {
    it("handles missing artifact gracefully", async () => {
      const { output } = await runCLI(["ctx", "NONEXISTENT"]);

      expect(output).toContain("Artifact NONEXISTENT not found");
      expect(output).toContain("Use --verbose flag for detailed error");
    });

    it("shows detailed error with --verbose flag", async () => {
      const { output } = await runCLI(["ctx", "INVALID.ID", "--verbose"]);

      expect(output).toContain("Artifact INVALID.ID not found");
      // Verbose mode might show additional error details
    });

    it("validates that artifact ID cannot be empty", async () => {
      const { output } = await runCLI(["ctx", ""]);

      // Empty string should be treated as missing argument
      expect(output).toContain("Artifact ID is required");
    });
  });

  describe("output format consistency", () => {
    it("displays context to stdout before success messages", async () => {
      const { output } = await runCLI(["ctx", "E.3.2", "--copy"]);

      const contextIndex = output.indexOf("# Artifact E.3.2:");
      const successIndex = output.indexOf("Context copied to clipboard");

      // Context should appear before success message
      expect(contextIndex).toBeGreaterThan(-1);
      expect(successIndex).toBeGreaterThan(contextIndex);
    });
  });

  describe("format-specific content validation", () => {
    it("standard format includes all required sections", async () => {
      const { output } = await runCLI(["ctx", "E.3.2"]);

      const requiredSections = [
        "# Artifact E.3.2:",
        "## Parent Context",
        "## Description",
        "## Acceptance Criteria",
        "## Relationships",
        "## Metadata",
        "---",
        "*Context generated by Kodebase CLI*",
      ];

      for (const section of requiredSections) {
        expect(output).toContain(section);
      }
    });

    it("compact format excludes parent context and metadata", async () => {
      const { output } = await runCLI(["ctx", "E.3.2", "--format=compact"]);

      expect(output).not.toContain("## Parent Context");
      expect(output).not.toContain("## Metadata");
      expect(output).not.toContain("---");
    });

    it("detailed format includes relationship details", async () => {
      const { output } = await runCLI(["ctx", "E.3.2", "--format=detailed"]);

      // Detailed format should expand relationships with titles
      expect(output).toContain("### Dependencies (blocked by)");
      expect(output).toContain("### Blocks");

      // Should include schema version in metadata
      expect(output).toContain("Schema Version:");
    });
  });
});
