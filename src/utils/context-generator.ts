/**
 * Context generation utility for artifacts
 *
 * Generates AI-ready context from artifacts including metadata,
 * parent context, and relationships.
 */

import { QueryService } from "@kodebase/artifacts";
import type { TAnyArtifact } from "@kodebase/core";

export interface ContextGenerationOptions {
  /** Base directory for project (defaults to process.cwd()) */
  baseDir?: string;
  /** Include parent context (initiative/milestone summaries) */
  includeParents?: boolean;
  /** Include file paths if available */
  includeFiles?: boolean;
}

/**
 * Generate AI context for an artifact
 *
 * Creates a formatted context string that includes:
 * - Artifact metadata (title, description, acceptance criteria)
 * - Parent context (initiative, milestone summaries)
 * - Relationships (blocked_by, blocks)
 * - Relevant file paths (if available)
 *
 * @param artifactId - The artifact ID to generate context for
 * @param options - Context generation options
 * @returns Formatted context string ready to paste into AI
 *
 * @example
 * ```ts
 * const context = await generateArtifactContext("A.1.1");
 * // Copy to clipboard
 * await clipboardy.write(context);
 * ```
 */
export async function generateArtifactContext(
  artifactId: string,
  options: ContextGenerationOptions = {},
): Promise<string> {
  const { baseDir = process.cwd(), includeParents = true } = options;

  const queryService = new QueryService(baseDir);

  // Load the artifact
  const results = await queryService.findArtifacts({});
  const artifactWithId = results.find((a) => a.id === artifactId);

  if (!artifactWithId) {
    throw new Error(`Artifact ${artifactId} not found`);
  }

  const { artifact } = artifactWithId;
  const parts: string[] = [];

  // Header
  parts.push(`# Artifact ${artifactId}: ${artifact.metadata.title}`);
  parts.push("");

  // Parent Context
  if (includeParents) {
    const ancestors = await queryService.getAncestors(artifactId);
    if (ancestors.length > 0) {
      parts.push("## Parent Context");
      parts.push("");

      for (const ancestor of ancestors) {
        const ancestorLevel = ancestor.id.split(".").length;
        const levelName =
          ancestorLevel === 1
            ? "Initiative"
            : ancestorLevel === 2
              ? "Milestone"
              : "Issue";

        parts.push(
          `**${levelName} ${ancestor.id}:** ${ancestor.artifact.metadata.title}`,
        );

        // Add summary if available
        const summary = getArtifactSummary(ancestor.artifact);
        if (summary) {
          parts.push(summary);
        }
        parts.push("");
      }
    }
  }

  // Description/Summary
  const summary = getArtifactSummary(artifact);
  if (summary) {
    parts.push("## Description");
    parts.push("");
    parts.push(summary);
    parts.push("");
  }

  // Acceptance Criteria / Success Criteria
  const criteria = getArtifactCriteria(artifact);
  if (criteria.length > 0) {
    const criteriaTitle = getCriteriaTitle(artifact);
    parts.push(`## ${criteriaTitle}`);
    parts.push("");
    for (const criterion of criteria) {
      parts.push(`- ${criterion}`);
    }
    parts.push("");
  }

  // Relationships
  const { blocks = [], blocked_by = [] } =
    artifact.metadata.relationships || {};

  if (blocked_by.length > 0 || blocks.length > 0) {
    parts.push("## Relationships");
    parts.push("");

    if (blocked_by.length > 0) {
      parts.push("**Dependencies (blocked by):**");
      for (const dep of blocked_by) {
        parts.push(`- ${dep}`);
      }
      parts.push("");
    }

    if (blocks.length > 0) {
      parts.push("**Blocks:**");
      for (const dep of blocks) {
        parts.push(`- ${dep}`);
      }
      parts.push("");
    }
  }

  // Metadata
  parts.push("## Metadata");
  parts.push("");
  parts.push(`- **Priority:** ${artifact.metadata.priority}`);
  parts.push(`- **Estimation:** ${artifact.metadata.estimation}`);
  parts.push(`- **Assignee:** ${artifact.metadata.assignee}`);
  parts.push("");

  // Footer
  parts.push("---");
  parts.push("*Context generated by Kodebase CLI*");

  return parts.join("\n");
}

/**
 * Get the summary/description from an artifact based on its type
 */
function getArtifactSummary(artifact: TAnyArtifact): string | undefined {
  const content = artifact.content;

  if ("summary" in content && content.summary) {
    return content.summary;
  }

  if ("vision" in content && content.vision) {
    return content.vision;
  }

  return undefined;
}

/**
 * Get acceptance/success criteria from an artifact based on its type
 */
function getArtifactCriteria(artifact: TAnyArtifact): string[] {
  const content = artifact.content;

  // Issue: acceptance_criteria
  if ("acceptance_criteria" in content && content.acceptance_criteria) {
    return Array.isArray(content.acceptance_criteria)
      ? content.acceptance_criteria
      : [content.acceptance_criteria];
  }

  // Milestone: validation
  if ("validation" in content && content.validation) {
    return Array.isArray(content.validation)
      ? content.validation
      : [content.validation];
  }

  // Initiative: success_criteria
  if ("success_criteria" in content && content.success_criteria) {
    return Array.isArray(content.success_criteria)
      ? content.success_criteria
      : [content.success_criteria];
  }

  return [];
}

/**
 * Get the appropriate criteria title based on artifact type
 */
function getCriteriaTitle(artifact: TAnyArtifact): string {
  const content = artifact.content;

  if ("acceptance_criteria" in content) {
    return "Acceptance Criteria";
  }

  if ("validation" in content) {
    return "Validation Criteria";
  }

  if ("success_criteria" in content) {
    return "Success Criteria";
  }

  return "Criteria";
}
